"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/profile/page",{

/***/ "(app-pages-browser)/./src/hooks/useUserData.ts":
/*!**********************************!*\
  !*** ./src/hooks/useUserData.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useUserData: () => (/* binding */ useUserData)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _app_firebase_FirebaseProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../app/firebase/FirebaseProvider */ \"(app-pages-browser)/./src/app/firebase/FirebaseProvider.tsx\");\n\n\nconst API_URL = 'https://studylist-server.onrender.com';\nconst isOnline = ()=>{\n    return typeof navigator !== 'undefined' && navigator.onLine;\n};\nconst useUserData = ()=>{\n    const { auth } = (0,_app_firebase_FirebaseProvider__WEBPACK_IMPORTED_MODULE_1__.useFirebase)();\n    const [userData, setUserData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const fetchUserData = async function(currentUser) {\n        let forceRefresh = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        if (isLoading) return;\n        try {\n            setLoading(true);\n            const startTime = performance.now();\n            // 如果不是強制刷新，才檢查快取\n            if (!forceRefresh && !isOnline()) {\n                console.log('Offline - using cached data if available');\n                const cacheKey = \"userData_\".concat(currentUser.uid);\n                const cachedData = sessionStorage.getItem(cacheKey);\n                if (cachedData) {\n                    const { data, timestamp } = JSON.parse(cachedData);\n                    const age = Math.round((Date.now() - timestamp) / 1000);\n                    console.log(\"Using cached data, age: \".concat(age, \" seconds\"));\n                    setUserData(data);\n                    return;\n                }\n                throw new Error('No cached data available and device is offline');\n            }\n            const token = await currentUser.getIdToken();\n            const response = await fetch(\"\".concat(API_URL, \"/api/users/\").concat(currentUser.uid), {\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            const data = await response.json();\n            const cacheKey = \"userData_\".concat(currentUser.uid);\n            sessionStorage.setItem(cacheKey, JSON.stringify({\n                data,\n                timestamp: Date.now()\n            }));\n            setUserData(data);\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n            setUserData(null);\n        } finally{\n            setLoading(false);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useUserData.useEffect\": ()=>{\n            let isMounted = true;\n            const unsubscribe = auth.onAuthStateChanged({\n                \"useUserData.useEffect.unsubscribe\": (user)=>{\n                    if (user && isMounted) {\n                        fetchUserData(user);\n                    } else {\n                        setUserData(null);\n                        setLoading(false);\n                    }\n                }\n            }[\"useUserData.useEffect.unsubscribe\"]);\n            return ({\n                \"useUserData.useEffect\": ()=>{\n                    isMounted = false;\n                    unsubscribe();\n                }\n            })[\"useUserData.useEffect\"];\n        }\n    }[\"useUserData.useEffect\"], [\n        auth\n    ]);\n    const addMaterial = async (materialData, topicId)=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) throw new Error('No user logged in');\n            const endpoint = \"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/topics/\").concat(topicId, \"/materials\");\n            console.log('Adding material:', {\n                payload: materialData,\n                topicId,\n                url: endpoint\n            });\n            const token = await user.getIdToken();\n            const response = await fetch(endpoint, {\n                method: 'POST',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(materialData)\n            });\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('Server error response:', errorText);\n                throw new Error(\"Failed to add material: \".concat(response.status));\n            }\n            const updatedUser = await response.json();\n            setUserData(updatedUser);\n            return true;\n        } catch (error) {\n            console.error('Error adding material:', error);\n            return false;\n        }\n    };\n    const updateProfile = async (data)=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) throw new Error('No user logged in');\n            const token = await user.getIdToken();\n            console.log('Updating profile with data:', data);\n            console.log('Sending request to:', \"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/profile\"));\n            const response = await fetch(\"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/profile\"), {\n                method: 'PUT',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(data)\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                console.error('Error response:', errorData);\n                throw new Error(errorData.error || 'Failed to update profile');\n            }\n            const updatedUser = await response.json();\n            console.log('Updated user data:', updatedUser);\n            setUserData(updatedUser);\n            return true;\n        } catch (error) {\n            console.error('Error updating profile:', error);\n            return false;\n        }\n    };\n    const updateTopicName = async (topicId, name)=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) throw new Error('No user logged in');\n            const token = await user.getIdToken();\n            console.log('Updating topic:', {\n                topicId,\n                name,\n                url: \"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/topics/\").concat(topicId)\n            });\n            const response = await fetch(\"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/topics/\").concat(topicId), {\n                method: 'PUT',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    name\n                })\n            });\n            if (!response.ok) {\n                const contentType = response.headers.get('content-type');\n                if (contentType && contentType.includes('application/json')) {\n                    const errorData = await response.json();\n                    throw new Error(errorData.error || 'Failed to update topic name');\n                } else {\n                    const text = await response.text();\n                    console.error('Unexpected response:', text);\n                    throw new Error(\"Server error: \".concat(response.status));\n                }\n            }\n            const updatedUser = await response.json();\n            setUserData(updatedUser);\n            return true;\n        } catch (error) {\n            console.error('Error updating topic name:', error);\n            return false;\n        }\n    };\n    const addTopic = async (name)=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) throw new Error('No user logged in');\n            const token = await user.getIdToken();\n            console.log('Sending request to:', \"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/topics\"));\n            const response = await fetch(\"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/topics\"), {\n                method: 'POST',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    name\n                })\n            });\n            if (!response.ok) {\n                const contentType = response.headers.get('content-type');\n                if (contentType && contentType.includes('application/json')) {\n                    const errorData = await response.json();\n                    throw new Error(errorData.error || 'Failed to add topic');\n                } else {\n                    const text = await response.text();\n                    console.error('Unexpected response:', text);\n                    throw new Error(\"Server error: \".concat(response.status));\n                }\n            }\n            const updatedUser = await response.json();\n            setUserData(updatedUser);\n            return true;\n        } catch (error) {\n            console.error('Error adding topic:', error);\n            return false;\n        }\n    };\n    const getContributionData = ()=>{\n        if (!(userData === null || userData === void 0 ? void 0 : userData.contributions)) return [];\n        // Sort contributions by date\n        const sortedContributions = [\n            ...userData.contributions\n        ].sort((a, b)=>new Date(a.date).getTime() - new Date(b.date).getTime());\n        return sortedContributions.map((contribution)=>({\n                date: contribution.date,\n                count: contribution.count,\n                studyCount: contribution.studyCount || 0 // 確保有 studyCount\n            }));\n    };\n    const completeMaterial = async (materialId, topicId)=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) throw new Error('No user logged in');\n            const endpoint = \"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/topics/\").concat(topicId, \"/materials/\").concat(materialId, \"/complete\");\n            console.log('Sending complete request to:', endpoint);\n            const token = await user.getIdToken();\n            const response = await fetch(endpoint, {\n                method: 'PUT',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                console.error('Complete material error response:', errorData);\n                throw new Error(errorData.message || errorData.error || 'Failed to update material completion status');\n            }\n            const updatedUser = await response.json();\n            setUserData(updatedUser);\n        } catch (error) {\n            console.error('Error completing material:', error);\n            throw error;\n        }\n    };\n    const uncompleteMaterial = async (materialId, topicId)=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) throw new Error('No user logged in');\n            const endpoint = \"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/topics/\").concat(topicId, \"/materials/\").concat(materialId, \"/uncomplete\");\n            const token = await user.getIdToken();\n            const response = await fetch(endpoint, {\n                method: 'PUT',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.message || 'Failed to update material completion status');\n            }\n            const updatedUser = await response.json();\n            setUserData(updatedUser);\n        } catch (error) {\n            console.error('Error uncompleting material:', error);\n            throw error;\n        }\n    };\n    const deleteMaterial = async (materialId, topicId)=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) throw new Error('No user logged in');\n            const endpoint = \"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/topics/\").concat(topicId, \"/materials/\").concat(materialId);\n            const token = await user.getIdToken();\n            console.log('Delete material request:', {\n                endpoint,\n                materialId,\n                topicId,\n                userUid: user.uid\n            });\n            const response = await fetch(endpoint, {\n                method: 'DELETE',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                console.error('Delete material failed:', errorData);\n                return false;\n            }\n            // 更新本地狀態而不是重新獲取所有數據\n            setUserData((prevData)=>{\n                if (!prevData) return null;\n                const updatedTopics = prevData.topics.map((topic)=>{\n                    if (topic._id !== topicId) return topic;\n                    const updatedCategories = {\n                        ...topic.categories\n                    };\n                    for (const type of [\n                        'webpage',\n                        'video',\n                        'podcast',\n                        'book'\n                    ]){\n                        updatedCategories[type] = updatedCategories[type].filter((m)=>m._id !== materialId);\n                    }\n                    return {\n                        ...topic,\n                        categories: updatedCategories\n                    };\n                });\n                return {\n                    ...prevData,\n                    topics: updatedTopics\n                };\n            });\n            return true;\n        } catch (error) {\n            console.error('Delete material error:', error);\n            return false;\n        }\n    };\n    const deleteTopic = async (topicId)=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) throw new Error('No user logged in');\n            const token = await user.getIdToken();\n            const response = await fetch(\"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/topics/\").concat(topicId), {\n                method: 'DELETE',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                console.error('Delete topic failed:', errorData);\n                return false;\n            }\n            // Update local state\n            setUserData((prevData)=>{\n                if (!prevData) return null;\n                return {\n                    ...prevData,\n                    topics: prevData.topics.filter((topic)=>topic._id !== topicId)\n                };\n            });\n            return true;\n        } catch (error) {\n            console.error('Delete topic error:', error);\n            return false;\n        }\n    };\n    return {\n        userData,\n        loading,\n        fetchUserData,\n        addMaterial,\n        updateProfile,\n        addTopic,\n        updateTopicName,\n        getContributionData,\n        completeMaterial,\n        uncompleteMaterial,\n        deleteMaterial,\n        deleteTopic\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VVc2VyRGF0YS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTRDO0FBRW1CO0FBRS9ELE1BQU1HLFVBQVU7QUFnQ2hCLE1BQU1DLFdBQVc7SUFDZixPQUFPLE9BQU9DLGNBQWMsZUFBZUEsVUFBVUMsTUFBTTtBQUM3RDtBQUVPLE1BQU1DLGNBQWM7SUFDekIsTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBR04sMkVBQVdBO0lBQzVCLE1BQU0sQ0FBQ08sVUFBVUMsWUFBWSxHQUFHViwrQ0FBUUEsQ0FBYztJQUN0RCxNQUFNLENBQUNXLFNBQVNDLFdBQVcsR0FBR1osK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDYSxXQUFXQyxhQUFhLEdBQUdkLCtDQUFRQSxDQUFDO0lBRTNDLE1BQU1lLGdCQUFnQixlQUFPQztZQUFrQkMsZ0ZBQWU7UUFDNUQsSUFBSUosV0FBVztRQUVmLElBQUk7WUFDRkQsV0FBVztZQUNYLE1BQU1NLFlBQVlDLFlBQVlDLEdBQUc7WUFFakMsaUJBQWlCO1lBQ2pCLElBQUksQ0FBQ0gsZ0JBQWdCLENBQUNiLFlBQVk7Z0JBQ2hDaUIsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLE1BQU1DLFdBQVcsWUFBNEIsT0FBaEJQLFlBQVlRLEdBQUc7Z0JBQzVDLE1BQU1DLGFBQWFDLGVBQWVDLE9BQU8sQ0FBQ0o7Z0JBRTFDLElBQUlFLFlBQVk7b0JBQ2QsTUFBTSxFQUFFRyxJQUFJLEVBQUVDLFNBQVMsRUFBRSxHQUFHQyxLQUFLQyxLQUFLLENBQUNOO29CQUN2QyxNQUFNTyxNQUFNQyxLQUFLQyxLQUFLLENBQUMsQ0FBQ0MsS0FBS2YsR0FBRyxLQUFLUyxTQUFRLElBQUs7b0JBQ2xEUixRQUFRQyxHQUFHLENBQUMsMkJBQStCLE9BQUpVLEtBQUk7b0JBQzNDdEIsWUFBWWtCO29CQUNaO2dCQUNGO2dCQUNBLE1BQU0sSUFBSVEsTUFBTTtZQUNsQjtZQUVBLE1BQU1DLFFBQVEsTUFBTXJCLFlBQVlz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UUFBUTtnQkFDUmpCLFNBQVM7b0JBQ1AsaUJBQWlCLFVBQWdCLE9BQU5KO29CQUMzQixnQkFBZ0I7Z0JBQ2xCO1lBQ0Y7WUFHRixJQUFJLENBQUNFLFNBQVNHLEVBQUUsRUFBRTtnQkFDaEIsTUFBTXNCLFlBQVksTUFBTXpCLFNBQVNLLElBQUk7Z0JBQ3JDdkIsUUFBUTBCLEtBQUssQ0FBQyx3QkFBd0JpQjtnQkFDdEMsT0FBTztZQUNUO1lBRUEscUJBQXFCO1lBQ3JCdEQsWUFBWStFLENBQUFBO2dCQUNWLElBQUksQ0FBQ0EsVUFBVSxPQUFPO2dCQUN0QixPQUFPO29CQUNMLEdBQUdBLFFBQVE7b0JBQ1hFLFFBQVFGLFNBQVNFLE1BQU0sQ0FBQ00sTUFBTSxDQUFDTCxDQUFBQSxRQUFTQSxNQUFNQyxHQUFHLEtBQUt2QztnQkFDeEQ7WUFDRjtZQUVBLE9BQU87UUFDVCxFQUFFLE9BQU9QLE9BQU87WUFDZDFCLFFBQVEwQixLQUFLLENBQUMsdUJBQXVCQTtZQUNyQyxPQUFPO1FBQ1Q7SUFDRjtJQUVBLE9BQU87UUFDTHRDO1FBQ0FFO1FBQ0FJO1FBQ0FxQztRQUNBVztRQUNBTztRQUNBTDtRQUNBTTtRQUNBWTtRQUNBRztRQUNBQztRQUNBWTtJQUNGO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL2pvcmRhbnd1L0RvY3VtZW50cy9HaXRIdWIvc3R1ZHlsaXN0L2NsaWVudC9zcmMvaG9va3MvdXNlVXNlckRhdGEudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFVzZXIgfSBmcm9tICcuLi90eXBlcy9Vc2VyJztcbmltcG9ydCB7IHVzZUZpcmViYXNlIH0gZnJvbSAnLi4vYXBwL2ZpcmViYXNlL0ZpcmViYXNlUHJvdmlkZXInO1xuXG5jb25zdCBBUElfVVJMID0gJ2h0dHBzOi8vc3R1ZHlsaXN0LXNlcnZlci5vbnJlbmRlci5jb20nO1xuXG50eXBlIE1hdGVyaWFsVHlwZSA9ICd3ZWJwYWdlJyB8ICdib29rJyB8ICd2aWRlbycgfCAncG9kY2FzdCc7XG5cbmludGVyZmFjZSBNYXRlcmlhbFBheWxvYWQge1xuICB0eXBlOiBNYXRlcmlhbFR5cGU7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIHVybDogc3RyaW5nIHwgbnVsbDtcbiAgcmF0aW5nOiBudW1iZXI7XG4gIGRhdGVBZGRlZDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgTWF0ZXJpYWxJbnB1dCB7XG4gIHR5cGU6IE1hdGVyaWFsVHlwZTtcbiAgdGl0bGU6IHN0cmluZztcbiAgdXJsPzogc3RyaW5nO1xuICByYXRpbmc/OiBudW1iZXI7XG4gIGRhdGVBZGRlZD86IERhdGU7XG59XG5cbmludGVyZmFjZSBNb25nb0NvbnRyaWJ1dGlvbiB7XG4gIGRhdGU6IHN0cmluZztcbiAgY291bnQ6IG51bWJlcjtcbiAgc3R1ZHlDb3VudD86IG51bWJlcjsgIC8vIOW+niBNb25nb0RCIOi/lOWbnueahOWPr+iDveaYr+WPr+mBuOeahFxufVxuXG5pbnRlcmZhY2UgQ29udHJpYnV0aW9uRGF0YSB7XG4gIGRhdGU6IHN0cmluZztcbiAgY291bnQ6IG51bWJlcjtcbiAgc3R1ZHlDb3VudDogbnVtYmVyOyAgLy8g5L2G5oiR5YCR55qE5oeJ55So5Lit6ZyA6KaB5a6D5piv5b+F6ZyA55qEXG59XG5cbmNvbnN0IGlzT25saW5lID0gKCkgPT4ge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLm9uTGluZTtcbn07XG5cbmV4cG9ydCBjb25zdCB1c2VVc2VyRGF0YSA9ICgpID0+IHtcbiAgY29uc3QgeyBhdXRoIH0gPSB1c2VGaXJlYmFzZSgpO1xuICBjb25zdCBbdXNlckRhdGEsIHNldFVzZXJEYXRhXSA9IHVzZVN0YXRlPFVzZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgY29uc3QgZmV0Y2hVc2VyRGF0YSA9IGFzeW5jIChjdXJyZW50VXNlcjogYW55LCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkgPT4ge1xuICAgIGlmIChpc0xvYWRpbmcpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyDlpoLmnpzkuI3mmK/lvLfliLbliLfmlrDvvIzmiY3mqqLmn6Xlv6vlj5ZcbiAgICAgIGlmICghZm9yY2VSZWZyZXNoICYmICFpc09ubGluZSgpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdPZmZsaW5lIC0gdXNpbmcgY2FjaGVkIGRhdGEgaWYgYXZhaWxhYmxlJyk7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYHVzZXJEYXRhXyR7Y3VycmVudFVzZXIudWlkfWA7XG4gICAgICAgIGNvbnN0IGNhY2hlZERhdGEgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKGNhY2hlS2V5KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChjYWNoZWREYXRhKSB7XG4gICAgICAgICAgY29uc3QgeyBkYXRhLCB0aW1lc3RhbXAgfSA9IEpTT04ucGFyc2UoY2FjaGVkRGF0YSk7XG4gICAgICAgICAgY29uc3QgYWdlID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIHRpbWVzdGFtcCkgLyAxMDAwKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgVXNpbmcgY2FjaGVkIGRhdGEsIGFnZTogJHthZ2V9IHNlY29uZHNgKTtcbiAgICAgICAgICBzZXRVc2VyRGF0YShkYXRhKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjYWNoZWQgZGF0YSBhdmFpbGFibGUgYW5kIGRldmljZSBpcyBvZmZsaW5lJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgY3VycmVudFVzZXIuZ2V0SWRUb2tlbigpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9hcGkvdXNlcnMvJHtjdXJyZW50VXNlci51aWR9YCwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYHVzZXJEYXRhXyR7Y3VycmVudFVzZXIudWlkfWA7XG4gICAgICBcbiAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oY2FjaGVLZXksIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICB9KSk7XG4gICAgICBcbiAgICAgIHNldFVzZXJEYXRhKGRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB1c2VyIGRhdGE6JywgZXJyb3IpO1xuICAgICAgc2V0VXNlckRhdGEobnVsbCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBpc01vdW50ZWQgPSB0cnVlO1xuICAgIFxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZWQoKHVzZXIpID0+IHtcbiAgICAgIGlmICh1c2VyICYmIGlzTW91bnRlZCkge1xuICAgICAgICBmZXRjaFVzZXJEYXRhKHVzZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VXNlckRhdGEobnVsbCk7XG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCBbYXV0aF0pO1xuXG4gIGNvbnN0IGFkZE1hdGVyaWFsID0gYXN5bmMgKG1hdGVyaWFsRGF0YTogTWF0ZXJpYWxJbnB1dCwgdG9waWNJZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhdXRoLmN1cnJlbnRVc2VyO1xuICAgICAgaWYgKCF1c2VyKSB0aHJvdyBuZXcgRXJyb3IoJ05vIHVzZXIgbG9nZ2VkIGluJyk7XG5cbiAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7QVBJX1VSTH0vYXBpL3VzZXJzLyR7dXNlci51aWR9L3RvcGljcy8ke3RvcGljSWR9L21hdGVyaWFsc2A7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgbWF0ZXJpYWw6Jywge1xuICAgICAgICBwYXlsb2FkOiBtYXRlcmlhbERhdGEsXG4gICAgICAgIHRvcGljSWQsXG4gICAgICAgIHVybDogZW5kcG9pbnRcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChlbmRwb2ludCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShtYXRlcmlhbERhdGEpXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NlcnZlciBlcnJvciByZXNwb25zZTonLCBlcnJvclRleHQpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhZGQgbWF0ZXJpYWw6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGRhdGVkVXNlciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHNldFVzZXJEYXRhKHVwZGF0ZWRVc2VyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgbWF0ZXJpYWw6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB1cGRhdGVQcm9maWxlID0gYXN5bmMgKGRhdGE6IHsgbmFtZTogc3RyaW5nOyBiaW86IHN0cmluZzsgcGhvdG9VUkw/OiBzdHJpbmcgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VyID0gYXV0aC5jdXJyZW50VXNlcjtcbiAgICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdObyB1c2VyIGxvZ2dlZCBpbicpO1xuXG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcgcHJvZmlsZSB3aXRoIGRhdGE6JywgZGF0YSk7XG4gICAgICBjb25zb2xlLmxvZygnU2VuZGluZyByZXF1ZXN0IHRvOicsIGAke0FQSV9VUkx9L2FwaS91c2Vycy8ke3VzZXIudWlkfS9wcm9maWxlYCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgIGAke0FQSV9VUkx9L2FwaS91c2Vycy8ke3VzZXIudWlkfS9wcm9maWxlYCxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXNwb25zZTonLCBlcnJvckRhdGEpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8ICdGYWlsZWQgdG8gdXBkYXRlIHByb2ZpbGUnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgdXBkYXRlZFVzZXIgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygnVXBkYXRlZCB1c2VyIGRhdGE6JywgdXBkYXRlZFVzZXIpO1xuICAgICAgc2V0VXNlckRhdGEodXBkYXRlZFVzZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHByb2ZpbGU6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB1cGRhdGVUb3BpY05hbWUgPSBhc3luYyAodG9waWNJZDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXNlciA9IGF1dGguY3VycmVudFVzZXI7XG4gICAgICBpZiAoIXVzZXIpIHRocm93IG5ldyBFcnJvcignTm8gdXNlciBsb2dnZWQgaW4nKTtcblxuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB1c2VyLmdldElkVG9rZW4oKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIHRvcGljOicsIHtcbiAgICAgICAgdG9waWNJZCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdXJsOiBgJHtBUElfVVJMfS9hcGkvdXNlcnMvJHt1c2VyLnVpZH0vdG9waWNzLyR7dG9waWNJZH1gXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYCR7QVBJX1VSTH0vYXBpL3VzZXJzLyR7dXNlci51aWR9L3RvcGljcy8ke3RvcGljSWR9YCxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgbmFtZSB9KVxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuICAgICAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8ICdGYWlsZWQgdG8gdXBkYXRlIHRvcGljIG5hbWUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgcmVzcG9uc2U6JywgdGV4dCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHVwZGF0ZWRVc2VyID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgc2V0VXNlckRhdGEodXBkYXRlZFVzZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHRvcGljIG5hbWU6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBhZGRUb3BpYyA9IGFzeW5jIChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXNlciA9IGF1dGguY3VycmVudFVzZXI7XG4gICAgICBpZiAoIXVzZXIpIHRocm93IG5ldyBFcnJvcignTm8gdXNlciBsb2dnZWQgaW4nKTtcblxuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB1c2VyLmdldElkVG9rZW4oKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1NlbmRpbmcgcmVxdWVzdCB0bzonLCBgJHtBUElfVVJMfS9hcGkvdXNlcnMvJHt1c2VyLnVpZH0vdG9waWNzYCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgIGAke0FQSV9VUkx9L2FwaS91c2Vycy8ke3VzZXIudWlkfS90b3BpY3NgLFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgbmFtZSB9KVxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuICAgICAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8ICdGYWlsZWQgdG8gYWRkIHRvcGljJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIHJlc3BvbnNlOicsIHRleHQpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGRhdGVkVXNlciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHNldFVzZXJEYXRhKHVwZGF0ZWRVc2VyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgdG9waWM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBnZXRDb250cmlidXRpb25EYXRhID0gKCk6IENvbnRyaWJ1dGlvbkRhdGFbXSA9PiB7XG4gICAgaWYgKCF1c2VyRGF0YT8uY29udHJpYnV0aW9ucykgcmV0dXJuIFtdO1xuICAgIFxuICAgIC8vIFNvcnQgY29udHJpYnV0aW9ucyBieSBkYXRlXG4gICAgY29uc3Qgc29ydGVkQ29udHJpYnV0aW9ucyA9IFsuLi51c2VyRGF0YS5jb250cmlidXRpb25zXS5zb3J0KFxuICAgICAgKGEsIGIpID0+IG5ldyBEYXRlKGEuZGF0ZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYi5kYXRlKS5nZXRUaW1lKClcbiAgICApO1xuICAgIFxuICAgIHJldHVybiBzb3J0ZWRDb250cmlidXRpb25zLm1hcCgoY29udHJpYnV0aW9uOiBNb25nb0NvbnRyaWJ1dGlvbik6IENvbnRyaWJ1dGlvbkRhdGEgPT4gKHtcbiAgICAgIGRhdGU6IGNvbnRyaWJ1dGlvbi5kYXRlLFxuICAgICAgY291bnQ6IGNvbnRyaWJ1dGlvbi5jb3VudCxcbiAgICAgIHN0dWR5Q291bnQ6IGNvbnRyaWJ1dGlvbi5zdHVkeUNvdW50IHx8IDAgIC8vIOeiuuS/neaciSBzdHVkeUNvdW50XG4gICAgfSkpO1xuICB9O1xuXG4gIGNvbnN0IGNvbXBsZXRlTWF0ZXJpYWwgPSBhc3luYyAobWF0ZXJpYWxJZDogc3RyaW5nLCB0b3BpY0lkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXNlciA9IGF1dGguY3VycmVudFVzZXI7XG4gICAgICBpZiAoIXVzZXIpIHRocm93IG5ldyBFcnJvcignTm8gdXNlciBsb2dnZWQgaW4nKTtcbiAgXG4gICAgICBjb25zdCBlbmRwb2ludCA9IGAke0FQSV9VUkx9L2FwaS91c2Vycy8ke3VzZXIudWlkfS90b3BpY3MvJHt0b3BpY0lkfS9tYXRlcmlhbHMvJHttYXRlcmlhbElkfS9jb21wbGV0ZWA7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdTZW5kaW5nIGNvbXBsZXRlIHJlcXVlc3QgdG86JywgZW5kcG9pbnQpO1xuICAgICAgXG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChlbmRwb2ludCwge1xuICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdDb21wbGV0ZSBtYXRlcmlhbCBlcnJvciByZXNwb25zZTonLCBlcnJvckRhdGEpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8ICdGYWlsZWQgdG8gdXBkYXRlIG1hdGVyaWFsIGNvbXBsZXRpb24gc3RhdHVzJyk7XG4gICAgICB9XG4gIFxuICAgICAgY29uc3QgdXBkYXRlZFVzZXIgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBzZXRVc2VyRGF0YSh1cGRhdGVkVXNlcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvbXBsZXRpbmcgbWF0ZXJpYWw6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHVuY29tcGxldGVNYXRlcmlhbCA9IGFzeW5jIChtYXRlcmlhbElkOiBzdHJpbmcsIHRvcGljSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VyID0gYXV0aC5jdXJyZW50VXNlcjtcbiAgICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdObyB1c2VyIGxvZ2dlZCBpbicpO1xuXG4gICAgICBjb25zdCBlbmRwb2ludCA9IGAke0FQSV9VUkx9L2FwaS91c2Vycy8ke3VzZXIudWlkfS90b3BpY3MvJHt0b3BpY0lkfS9tYXRlcmlhbHMvJHttYXRlcmlhbElkfS91bmNvbXBsZXRlYDtcbiAgICAgIFxuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB1c2VyLmdldElkVG9rZW4oKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZW5kcG9pbnQsIHtcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHVwZGF0ZSBtYXRlcmlhbCBjb21wbGV0aW9uIHN0YXR1cycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGRhdGVkVXNlciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHNldFVzZXJEYXRhKHVwZGF0ZWRVc2VyKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdW5jb21wbGV0aW5nIG1hdGVyaWFsOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBkZWxldGVNYXRlcmlhbCA9IGFzeW5jIChtYXRlcmlhbElkOiBzdHJpbmcsIHRvcGljSWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VyID0gYXV0aC5jdXJyZW50VXNlcjtcbiAgICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdObyB1c2VyIGxvZ2dlZCBpbicpO1xuXG4gICAgICBjb25zdCBlbmRwb2ludCA9IGAke0FQSV9VUkx9L2FwaS91c2Vycy8ke3VzZXIudWlkfS90b3BpY3MvJHt0b3BpY0lkfS9tYXRlcmlhbHMvJHttYXRlcmlhbElkfWA7XG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnRGVsZXRlIG1hdGVyaWFsIHJlcXVlc3Q6Jywge1xuICAgICAgICBlbmRwb2ludCxcbiAgICAgICAgbWF0ZXJpYWxJZCxcbiAgICAgICAgdG9waWNJZCxcbiAgICAgICAgdXNlclVpZDogdXNlci51aWRcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGVuZHBvaW50LCB7XG4gICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdEZWxldGUgbWF0ZXJpYWwgZmFpbGVkOicsIGVycm9yRGF0YSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8g5pu05paw5pys5Zyw54uA5oWL6ICM5LiN5piv6YeN5paw542y5Y+W5omA5pyJ5pW45pOaXG4gICAgICBzZXRVc2VyRGF0YShwcmV2RGF0YSA9PiB7XG4gICAgICAgIGlmICghcHJldkRhdGEpIHJldHVybiBudWxsO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdXBkYXRlZFRvcGljcyA9IHByZXZEYXRhLnRvcGljcy5tYXAodG9waWMgPT4ge1xuICAgICAgICAgIGlmICh0b3BpYy5faWQgIT09IHRvcGljSWQpIHJldHVybiB0b3BpYztcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB1cGRhdGVkQ2F0ZWdvcmllcyA9IHsgLi4udG9waWMuY2F0ZWdvcmllcyB9O1xuICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBbJ3dlYnBhZ2UnLCAndmlkZW8nLCAncG9kY2FzdCcsICdib29rJ10gYXMgY29uc3QpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRDYXRlZ29yaWVzW3R5cGVdID0gdXBkYXRlZENhdGVnb3JpZXNbdHlwZV0uZmlsdGVyKFxuICAgICAgICAgICAgICBtID0+IG0uX2lkICE9PSBtYXRlcmlhbElkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udG9waWMsXG4gICAgICAgICAgICBjYXRlZ29yaWVzOiB1cGRhdGVkQ2F0ZWdvcmllc1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ucHJldkRhdGEsXG4gICAgICAgICAgdG9waWNzOiB1cGRhdGVkVG9waWNzXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0RlbGV0ZSBtYXRlcmlhbCBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGRlbGV0ZVRvcGljID0gYXN5bmMgKHRvcGljSWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VyID0gYXV0aC5jdXJyZW50VXNlcjtcbiAgICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdObyB1c2VyIGxvZ2dlZCBpbicpO1xuXG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYCR7QVBJX1VSTH0vYXBpL3VzZXJzLyR7dXNlci51aWR9L3RvcGljcy8ke3RvcGljSWR9YCxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdEZWxldGUgdG9waWMgZmFpbGVkOicsIGVycm9yRGF0YSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGxvY2FsIHN0YXRlXG4gICAgICBzZXRVc2VyRGF0YShwcmV2RGF0YSA9PiB7XG4gICAgICAgIGlmICghcHJldkRhdGEpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnByZXZEYXRhLFxuICAgICAgICAgIHRvcGljczogcHJldkRhdGEudG9waWNzLmZpbHRlcih0b3BpYyA9PiB0b3BpYy5faWQgIT09IHRvcGljSWQpXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0RlbGV0ZSB0b3BpYyBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7IFxuICAgIHVzZXJEYXRhLCBcbiAgICBsb2FkaW5nLCBcbiAgICBmZXRjaFVzZXJEYXRhLCBcbiAgICBhZGRNYXRlcmlhbCxcbiAgICB1cGRhdGVQcm9maWxlLFxuICAgIGFkZFRvcGljLFxuICAgIHVwZGF0ZVRvcGljTmFtZSxcbiAgICBnZXRDb250cmlidXRpb25EYXRhLFxuICAgIGNvbXBsZXRlTWF0ZXJpYWwsXG4gICAgdW5jb21wbGV0ZU1hdGVyaWFsLFxuICAgIGRlbGV0ZU1hdGVyaWFsLFxuICAgIGRlbGV0ZVRvcGljXG4gIH07XG59OyJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUZpcmViYXNlIiwiQVBJX1VSTCIsImlzT25saW5lIiwibmF2aWdhdG9yIiwib25MaW5lIiwidXNlVXNlckRhdGEiLCJhdXRoIiwidXNlckRhdGEiLCJzZXRVc2VyRGF0YSIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiZmV0Y2hVc2VyRGF0YSIsImN1cnJlbnRVc2VyIiwiZm9yY2VSZWZyZXNoIiwic3RhcnRUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJjb25zb2xlIiwibG9nIiwiY2FjaGVLZXkiLCJ1aWQiLCJjYWNoZWREYXRhIiwic2Vzc2lvblN0b3JhZ2UiLCJnZXRJdGVtIiwiZGF0YSIsInRpbWVzdGFtcCIsIkpTT04iLCJwYXJzZSIsImFnZSIsIk1hdGgiLCJyb3VuZCIsIkRhdGUiLCJFcnJvciIsInRva2VuIiwiZ2V0SWRUb2tlbiIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwib2siLCJzdGF0dXMiLCJqc29uIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImVycm9yIiwiaXNNb3VudGVkIiwidW5zdWJzY3JpYmUiLCJvbkF1dGhTdGF0ZUNoYW5nZWQiLCJ1c2VyIiwiYWRkTWF0ZXJpYWwiLCJtYXRlcmlhbERhdGEiLCJ0b3BpY0lkIiwiZW5kcG9pbnQiLCJwYXlsb2FkIiwidXJsIiwibWV0aG9kIiwiYm9keSIsImVycm9yVGV4dCIsInRleHQiLCJ1cGRhdGVkVXNlciIsInVwZGF0ZVByb2ZpbGUiLCJlcnJvckRhdGEiLCJ1cGRhdGVUb3BpY05hbWUiLCJuYW1lIiwiY29udGVudFR5cGUiLCJnZXQiLCJpbmNsdWRlcyIsImFkZFRvcGljIiwiZ2V0Q29udHJpYnV0aW9uRGF0YSIsImNvbnRyaWJ1dGlvbnMiLCJzb3J0ZWRDb250cmlidXRpb25zIiwic29ydCIsImEiLCJiIiwiZGF0ZSIsImdldFRpbWUiLCJtYXAiLCJjb250cmlidXRpb24iLCJjb3VudCIsInN0dWR5Q291bnQiLCJjb21wbGV0ZU1hdGVyaWFsIiwibWF0ZXJpYWxJZCIsIm1lc3NhZ2UiLCJ1bmNvbXBsZXRlTWF0ZXJpYWwiLCJkZWxldGVNYXRlcmlhbCIsInVzZXJVaWQiLCJwcmV2RGF0YSIsInVwZGF0ZWRUb3BpY3MiLCJ0b3BpY3MiLCJ0b3BpYyIsIl9pZCIsInVwZGF0ZWRDYXRlZ29yaWVzIiwiY2F0ZWdvcmllcyIsInR5cGUiLCJmaWx0ZXIiLCJtIiwiZGVsZXRlVG9waWMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useUserData.ts\n"));

/***/ })

});