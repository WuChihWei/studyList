"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/profile/page",{

/***/ "(app-pages-browser)/./src/hooks/useUserData.ts":
/*!**********************************!*\
  !*** ./src/hooks/useUserData.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useUserData: () => (/* binding */ useUserData)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _app_firebase_FirebaseProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../app/firebase/FirebaseProvider */ \"(app-pages-browser)/./src/app/firebase/FirebaseProvider.tsx\");\n\n\nconst API_URL = 'https://studylist-server.onrender.com';\nconst useUserData = ()=>{\n    const { auth } = (0,_app_firebase_FirebaseProvider__WEBPACK_IMPORTED_MODULE_1__.useFirebase)();\n    const [userData, setUserData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const fetchUserData = async (currentUser)=>{\n        if (isLoading) return;\n        const startTime = performance.now();\n        console.log('=== API Request Started ===');\n        console.log('Start time:', new Date().toISOString());\n        try {\n            setLoading(true);\n            const cacheKey = \"userData_\".concat(currentUser.uid);\n            const cachedData = sessionStorage.getItem(cacheKey);\n            if (cachedData) {\n                const { data, timestamp } = JSON.parse(cachedData);\n                const cacheAge = Date.now() - timestamp;\n                if (cacheAge < 5 * 60 * 1000) {\n                    console.log('Using cached data, age:', Math.round(cacheAge / 1000), 'seconds');\n                    setUserData(data);\n                    return;\n                }\n            }\n            console.log('Cache miss or expired, fetching from API...');\n            const tokenStartTime = performance.now();\n            const token = await currentUser.getIdToken();\n            console.log('Token fetch time:', Math.round(performance.now() - tokenStartTime), 'ms');\n            const fetchStartTime = performance.now();\n            const response = await fetch(\"\".concat(API_URL, \"/api/users/\").concat(currentUser.uid), {\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                }\n            });\n            const data = await response.json();\n            const fetchEndTime = performance.now();\n            console.log('API fetch time:', Math.round(fetchEndTime - fetchStartTime), 'ms');\n            sessionStorage.setItem(cacheKey, JSON.stringify({\n                data,\n                timestamp: Date.now()\n            }));\n            setUserData(data);\n        } catch (error) {\n            console.error('Error:', error);\n            setUserData(null);\n        } finally{\n            const endTime = performance.now();\n            console.log('=== API Request Completed ===');\n            console.log('End time:', new Date().toISOString());\n            console.log('Total execution time:', Math.round(endTime - startTime), 'ms');\n            console.log('========================');\n            setLoading(false);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useUserData.useEffect\": ()=>{\n            let isMounted = true;\n            const unsubscribe = auth.onAuthStateChanged({\n                \"useUserData.useEffect.unsubscribe\": (user)=>{\n                    if (user && isMounted) {\n                        fetchUserData(user);\n                    } else {\n                        setUserData(null);\n                        setLoading(false);\n                    }\n                }\n            }[\"useUserData.useEffect.unsubscribe\"]);\n            return ({\n                \"useUserData.useEffect\": ()=>{\n                    isMounted = false;\n                    unsubscribe();\n                }\n            })[\"useUserData.useEffect\"];\n        }\n    }[\"useUserData.useEffect\"], [\n        auth\n    ]);\n    const addMaterial = async (materialData, topicId)=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) throw new Error('No user logged in');\n            const endpoint = \"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/topics/\").concat(topicId, \"/materials\");\n            console.log('Adding material:', {\n                payload: materialData,\n                topicId,\n                url: endpoint\n            });\n            const token = await user.getIdToken();\n            const response = await fetch(endpoint, {\n                method: 'POST',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(materialData)\n            });\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('Server error response:', errorText);\n                throw new Error(\"Failed to add material: \".concat(response.status));\n            }\n            const updatedUser = await response.json();\n            setUserData(updatedUser);\n            return true;\n        } catch (error) {\n            console.error('Error adding material:', error);\n            return false;\n        }\n    };\n    const updateProfile = async (data)=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) throw new Error('No user logged in');\n            const token = await user.getIdToken();\n            console.log('Updating profile with data:', data);\n            console.log('Sending request to:', \"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/profile\"));\n            const response = await fetch(\"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/profile\"), {\n                method: 'PUT',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(data)\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                console.error('Error response:', errorData);\n                throw new Error(errorData.error || 'Failed to update profile');\n            }\n            const updatedUser = await response.json();\n            console.log('Updated user data:', updatedUser);\n            setUserData(updatedUser);\n            return true;\n        } catch (error) {\n            console.error('Error updating profile:', error);\n            return false;\n        }\n    };\n    const updateTopicName = async (topicId, name)=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) throw new Error('No user logged in');\n            const token = await user.getIdToken();\n            console.log('Updating topic:', {\n                topicId,\n                name,\n                url: \"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/topics/\").concat(topicId)\n            });\n            const response = await fetch(\"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/topics/\").concat(topicId), {\n                method: 'PUT',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    name\n                })\n            });\n            if (!response.ok) {\n                const contentType = response.headers.get('content-type');\n                if (contentType && contentType.includes('application/json')) {\n                    const errorData = await response.json();\n                    throw new Error(errorData.error || 'Failed to update topic name');\n                } else {\n                    const text = await response.text();\n                    console.error('Unexpected response:', text);\n                    throw new Error(\"Server error: \".concat(response.status));\n                }\n            }\n            const updatedUser = await response.json();\n            setUserData(updatedUser);\n            return true;\n        } catch (error) {\n            console.error('Error updating topic name:', error);\n            return false;\n        }\n    };\n    const addTopic = async (name)=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) throw new Error('No user logged in');\n            const token = await user.getIdToken();\n            console.log('Sending request to:', \"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/topics\"));\n            const response = await fetch(\"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/topics\"), {\n                method: 'POST',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    name\n                })\n            });\n            if (!response.ok) {\n                const contentType = response.headers.get('content-type');\n                if (contentType && contentType.includes('application/json')) {\n                    const errorData = await response.json();\n                    throw new Error(errorData.error || 'Failed to add topic');\n                } else {\n                    const text = await response.text();\n                    console.error('Unexpected response:', text);\n                    throw new Error(\"Server error: \".concat(response.status));\n                }\n            }\n            const updatedUser = await response.json();\n            setUserData(updatedUser);\n            return true;\n        } catch (error) {\n            console.error('Error adding topic:', error);\n            return false;\n        }\n    };\n    const getContributionData = ()=>{\n        if (!(userData === null || userData === void 0 ? void 0 : userData.contributions)) return [];\n        // Sort contributions by date\n        const sortedContributions = [\n            ...userData.contributions\n        ].sort((a, b)=>new Date(a.date).getTime() - new Date(b.date).getTime());\n        return sortedContributions.map((contribution)=>({\n                date: contribution.date,\n                count: contribution.count,\n                studyCount: contribution.studyCount || 0 // 確保有 studyCount\n            }));\n    };\n    const completeMaterial = async (materialId, topicId)=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) throw new Error('No user logged in');\n            const endpoint = \"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/topics/\").concat(topicId, \"/materials/\").concat(materialId, \"/complete\");\n            console.log('Sending complete request to:', endpoint);\n            const token = await user.getIdToken();\n            const response = await fetch(endpoint, {\n                method: 'PUT',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                console.error('Complete material error response:', errorData);\n                throw new Error(errorData.message || errorData.error || 'Failed to update material completion status');\n            }\n            const updatedUser = await response.json();\n            setUserData(updatedUser);\n        } catch (error) {\n            console.error('Error completing material:', error);\n            throw error;\n        }\n    };\n    const uncompleteMaterial = async (materialId, topicId)=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) throw new Error('No user logged in');\n            const endpoint = \"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/topics/\").concat(topicId, \"/materials/\").concat(materialId, \"/uncomplete\");\n            const token = await user.getIdToken();\n            const response = await fetch(endpoint, {\n                method: 'PUT',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.message || 'Failed to update material completion status');\n            }\n            const updatedUser = await response.json();\n            setUserData(updatedUser);\n        } catch (error) {\n            console.error('Error uncompleting material:', error);\n            throw error;\n        }\n    };\n    const deleteMaterial = async (materialId, topicId)=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) throw new Error('No user logged in');\n            const endpoint = \"\".concat(API_URL, \"/api/users/\").concat(user.uid, \"/topics/\").concat(topicId, \"/materials/\").concat(materialId);\n            const token = await user.getIdToken();\n            console.log('Delete material request:', {\n                endpoint,\n                materialId,\n                topicId,\n                userUid: user.uid\n            });\n            const response = await fetch(endpoint, {\n                method: 'DELETE',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                console.error('Delete material failed:', errorData);\n                return false;\n            }\n            await fetchUserData(user);\n            return true;\n        } catch (error) {\n            console.error('Delete material error:', error);\n            return false;\n        }\n    };\n    return {\n        userData,\n        loading,\n        fetchUserData,\n        addMaterial,\n        updateProfile,\n        addTopic,\n        updateTopicName,\n        getContributionData,\n        completeMaterial,\n        uncompleteMaterial,\n        deleteMaterial\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VVc2VyRGF0YS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTRDO0FBRW1CO0FBRS9ELE1BQU1HLFVBQVU7QUFnQ1QsTUFBTUMsY0FBYztJQUN6QixNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHSCwyRUFBV0E7SUFDNUIsTUFBTSxDQUFDSSxVQUFVQyxZQUFZLEdBQUdQLCtDQUFRQSxDQUFjO0lBQ3RELE1BQU0sQ0FBQ1EsU0FBU0MsV0FBVyxHQUFHVCwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNVLFdBQVdDLGFBQWEsR0FBR1gsK0NBQVFBLENBQUM7SUFFM0MsTUFBTVksZ0JBQWdCLE9BQU9DO1FBQzNCLElBQUlILFdBQVc7UUFFZixNQUFNSSxZQUFZQyxZQUFZQyxHQUFHO1FBQ2pDQyxRQUFRQyxHQUFHLENBQUM7UUFDWkQsUUFBUUMsR0FBRyxDQUFDLGVBQWUsSUFBSUMsT0FBT0MsV0FBVztRQUVqRCxJQUFJO1lBQ0ZYLFdBQVc7WUFDWCxNQUFNWSxXQUFXLFlBQTRCLE9BQWhCUixZQUFZUyxHQUFHO1lBQzVDLE1BQU1DLGFBQWFDLGVBQWVDLE9BQU8sQ0FBQ0o7WUFFMUMsSUFBSUUsWUFBWTtnQkFDZCxNQUFNLEVBQUVHLElBQUksRUFBRUMsU0FBUyxFQUFFLEdBQUdDLEtBQUtDLEtBQUssQ0FBQ047Z0JBQ3ZDLE1BQU1PLFdBQVdYLEtBQUtILEdBQUcsS0FBS1c7Z0JBQzlCLElBQUlHLFdBQVcsSUFBSSxLQUFLLE1BQU07b0JBQzVCYixRQUFRQyxHQUFHLENBQUMsMkJBQTJCYSxLQUFLQyxLQUFLLENBQUNGLFdBQVcsT0FBTztvQkFDcEV2QixZQUFZbUI7b0JBQ1o7Z0JBQ0Y7WUFDRjtZQUVBVCxRQUFRQyxHQUFHLENBQUM7WUFDWixNQUFNZSxpQkFBaUJsQixZQUFZQyxHQUFHO1lBQ3RDLE1BQU1rQixRQUFRLE1BQU1yQixZQUFZc0IsVUFBVTtZQUMxQ2xCLFFBQVFDLEdBQUcsQ0FBQyxx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QUVuQ2xCLFFBQVFDLEdBQUcsQ0FBQyw0QkFBNEI7Z0JBQ3RDb0M7Z0JBQ0ErQjtnQkFDQWpDO2dCQUNBcUMsU0FBU3hDLEtBQUszQixHQUFHO1lBQ25CO1lBRUEsTUFBTWUsV0FBVyxNQUFNQyxNQUFNZ0IsVUFBVTtnQkFDckNHLFFBQVE7Z0JBQ1JsQixTQUFTO29CQUNQLGlCQUFpQixVQUFnQixPQUFOTDtvQkFDM0IsZ0JBQWdCO2dCQUNsQjtZQUNGO1lBRUEsSUFBSSxDQUFDRyxTQUFTc0IsRUFBRSxFQUFFO2dCQUNoQixNQUFNTSxZQUFZLE1BQU01QixTQUFTRyxJQUFJO2dCQUNyQ3ZCLFFBQVEyQixLQUFLLENBQUMsMkJBQTJCcUI7Z0JBQ3pDLE9BQU87WUFDVDtZQUVBLE1BQU1yRCxjQUFjcUM7WUFDcEIsT0FBTztRQUNULEVBQUUsT0FBT0wsT0FBTztZQUNkM0IsUUFBUTJCLEtBQUssQ0FBQywwQkFBMEJBO1lBQ3hDLE9BQU87UUFDVDtJQUNGO0lBRUEsT0FBTztRQUNMdEM7UUFDQUU7UUFDQUk7UUFDQXNDO1FBQ0FjO1FBQ0FPO1FBQ0FMO1FBQ0FNO1FBQ0FZO1FBQ0FHO1FBQ0FDO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvam9yZGFud3UvRG9jdW1lbnRzL0dpdEh1Yi9zdHVkeWxpc3QvY2xpZW50L3NyYy9ob29rcy91c2VVc2VyRGF0YS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgVXNlciB9IGZyb20gJy4uL3R5cGVzL1VzZXInO1xuaW1wb3J0IHsgdXNlRmlyZWJhc2UgfSBmcm9tICcuLi9hcHAvZmlyZWJhc2UvRmlyZWJhc2VQcm92aWRlcic7XG5cbmNvbnN0IEFQSV9VUkwgPSAnaHR0cHM6Ly9zdHVkeWxpc3Qtc2VydmVyLm9ucmVuZGVyLmNvbSc7XG5cbnR5cGUgTWF0ZXJpYWxUeXBlID0gJ3dlYnBhZ2UnIHwgJ2Jvb2snIHwgJ3ZpZGVvJyB8ICdwb2RjYXN0JztcblxuaW50ZXJmYWNlIE1hdGVyaWFsUGF5bG9hZCB7XG4gIHR5cGU6IE1hdGVyaWFsVHlwZTtcbiAgdGl0bGU6IHN0cmluZztcbiAgdXJsOiBzdHJpbmcgfCBudWxsO1xuICByYXRpbmc6IG51bWJlcjtcbiAgZGF0ZUFkZGVkOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBNYXRlcmlhbElucHV0IHtcbiAgdHlwZTogTWF0ZXJpYWxUeXBlO1xuICB0aXRsZTogc3RyaW5nO1xuICB1cmw/OiBzdHJpbmc7XG4gIHJhdGluZz86IG51bWJlcjtcbiAgZGF0ZUFkZGVkPzogRGF0ZTtcbn1cblxuaW50ZXJmYWNlIE1vbmdvQ29udHJpYnV0aW9uIHtcbiAgZGF0ZTogc3RyaW5nO1xuICBjb3VudDogbnVtYmVyO1xuICBzdHVkeUNvdW50PzogbnVtYmVyOyAgLy8g5b6eIE1vbmdvREIg6L+U5Zue55qE5Y+v6IO95piv5Y+v6YG455qEXG59XG5cbmludGVyZmFjZSBDb250cmlidXRpb25EYXRhIHtcbiAgZGF0ZTogc3RyaW5nO1xuICBjb3VudDogbnVtYmVyO1xuICBzdHVkeUNvdW50OiBudW1iZXI7ICAvLyDkvYbmiJHlgJHnmoTmh4nnlKjkuK3pnIDopoHlroPmmK/lv4XpnIDnmoRcbn1cblxuZXhwb3J0IGNvbnN0IHVzZVVzZXJEYXRhID0gKCkgPT4ge1xuICBjb25zdCB7IGF1dGggfSA9IHVzZUZpcmViYXNlKCk7XG4gIGNvbnN0IFt1c2VyRGF0YSwgc2V0VXNlckRhdGFdID0gdXNlU3RhdGU8VXNlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICBjb25zdCBmZXRjaFVzZXJEYXRhID0gYXN5bmMgKGN1cnJlbnRVc2VyOiBhbnkpID0+IHtcbiAgICBpZiAoaXNMb2FkaW5nKSByZXR1cm47XG4gICAgXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc29sZS5sb2coJz09PSBBUEkgUmVxdWVzdCBTdGFydGVkID09PScpO1xuICAgIGNvbnNvbGUubG9nKCdTdGFydCB0aW1lOicsIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBjb25zdCBjYWNoZUtleSA9IGB1c2VyRGF0YV8ke2N1cnJlbnRVc2VyLnVpZH1gO1xuICAgICAgY29uc3QgY2FjaGVkRGF0YSA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oY2FjaGVLZXkpO1xuICAgICAgXG4gICAgICBpZiAoY2FjaGVkRGF0YSkge1xuICAgICAgICBjb25zdCB7IGRhdGEsIHRpbWVzdGFtcCB9ID0gSlNPTi5wYXJzZShjYWNoZWREYXRhKTtcbiAgICAgICAgY29uc3QgY2FjaGVBZ2UgPSBEYXRlLm5vdygpIC0gdGltZXN0YW1wO1xuICAgICAgICBpZiAoY2FjaGVBZ2UgPCA1ICogNjAgKiAxMDAwKSB7IC8vIDXliIbpkJjnt6nlrZhcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgY2FjaGVkIGRhdGEsIGFnZTonLCBNYXRoLnJvdW5kKGNhY2hlQWdlIC8gMTAwMCksICdzZWNvbmRzJyk7XG4gICAgICAgICAgc2V0VXNlckRhdGEoZGF0YSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdDYWNoZSBtaXNzIG9yIGV4cGlyZWQsIGZldGNoaW5nIGZyb20gQVBJLi4uJyk7XG4gICAgICBjb25zdCB0b2tlblN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBjdXJyZW50VXNlci5nZXRJZFRva2VuKCk7XG4gICAgICBjb25zb2xlLmxvZygnVG9rZW4gZmV0Y2ggdGltZTonLCBNYXRoLnJvdW5kKHBlcmZvcm1hbmNlLm5vdygpIC0gdG9rZW5TdGFydFRpbWUpLCAnbXMnKTtcblxuICAgICAgY29uc3QgZmV0Y2hTdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vYXBpL3VzZXJzLyR7Y3VycmVudFVzZXIudWlkfWAsIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnN0IGZldGNoRW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc29sZS5sb2coJ0FQSSBmZXRjaCB0aW1lOicsIE1hdGgucm91bmQoZmV0Y2hFbmRUaW1lIC0gZmV0Y2hTdGFydFRpbWUpLCAnbXMnKTtcbiAgICAgIFxuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShjYWNoZUtleSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBkYXRhLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgIH0pKTtcbiAgICAgIFxuICAgICAgc2V0VXNlckRhdGEoZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yOicsIGVycm9yKTtcbiAgICAgIHNldFVzZXJEYXRhKG51bGwpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zb2xlLmxvZygnPT09IEFQSSBSZXF1ZXN0IENvbXBsZXRlZCA9PT0nKTtcbiAgICAgIGNvbnNvbGUubG9nKCdFbmQgdGltZTonLCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgY29uc29sZS5sb2coJ1RvdGFsIGV4ZWN1dGlvbiB0aW1lOicsIE1hdGgucm91bmQoZW5kVGltZSAtIHN0YXJ0VGltZSksICdtcycpO1xuICAgICAgY29uc29sZS5sb2coJz09PT09PT09PT09PT09PT09PT09PT09PScpO1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGlzTW91bnRlZCA9IHRydWU7XG4gICAgXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBhdXRoLm9uQXV0aFN0YXRlQ2hhbmdlZCgodXNlcikgPT4ge1xuICAgICAgaWYgKHVzZXIgJiYgaXNNb3VudGVkKSB7XG4gICAgICAgIGZldGNoVXNlckRhdGEodXNlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRVc2VyRGF0YShudWxsKTtcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFthdXRoXSk7XG5cbiAgY29uc3QgYWRkTWF0ZXJpYWwgPSBhc3luYyAobWF0ZXJpYWxEYXRhOiBNYXRlcmlhbElucHV0LCB0b3BpY0lkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXNlciA9IGF1dGguY3VycmVudFVzZXI7XG4gICAgICBpZiAoIXVzZXIpIHRocm93IG5ldyBFcnJvcignTm8gdXNlciBsb2dnZWQgaW4nKTtcblxuICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHtBUElfVVJMfS9hcGkvdXNlcnMvJHt1c2VyLnVpZH0vdG9waWNzLyR7dG9waWNJZH0vbWF0ZXJpYWxzYDtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0FkZGluZyBtYXRlcmlhbDonLCB7XG4gICAgICAgIHBheWxvYWQ6IG1hdGVyaWFsRGF0YSxcbiAgICAgICAgdG9waWNJZCxcbiAgICAgICAgdXJsOiBlbmRwb2ludFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdXNlci5nZXRJZFRva2VuKCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGVuZHBvaW50LCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG1hdGVyaWFsRGF0YSlcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignU2VydmVyIGVycm9yIHJlc3BvbnNlOicsIGVycm9yVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGFkZCBtYXRlcmlhbDogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwZGF0ZWRVc2VyID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgc2V0VXNlckRhdGEodXBkYXRlZFVzZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBtYXRlcmlhbDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHVwZGF0ZVByb2ZpbGUgPSBhc3luYyAoZGF0YTogeyBuYW1lOiBzdHJpbmc7IGJpbzogc3RyaW5nOyBwaG90b1VSTD86IHN0cmluZyB9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhdXRoLmN1cnJlbnRVc2VyO1xuICAgICAgaWYgKCF1c2VyKSB0aHJvdyBuZXcgRXJyb3IoJ05vIHVzZXIgbG9nZ2VkIGluJyk7XG5cbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdXNlci5nZXRJZFRva2VuKCk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGluZyBwcm9maWxlIHdpdGggZGF0YTonLCBkYXRhKTtcbiAgICAgIGNvbnNvbGUubG9nKCdTZW5kaW5nIHJlcXVlc3QgdG86JywgYCR7QVBJX1VSTH0vYXBpL3VzZXJzLyR7dXNlci51aWR9L3Byb2ZpbGVgKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYCR7QVBJX1VSTH0vYXBpL3VzZXJzLyR7dXNlci51aWR9L3Byb2ZpbGVgLFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlc3BvbnNlOicsIGVycm9yRGF0YSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgJ0ZhaWxlZCB0byB1cGRhdGUgcHJvZmlsZScpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB1cGRhdGVkVXNlciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGVkIHVzZXIgZGF0YTonLCB1cGRhdGVkVXNlcik7XG4gICAgICBzZXRVc2VyRGF0YSh1cGRhdGVkVXNlcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgcHJvZmlsZTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHVwZGF0ZVRvcGljTmFtZSA9IGFzeW5jICh0b3BpY0lkOiBzdHJpbmcsIG5hbWU6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VyID0gYXV0aC5jdXJyZW50VXNlcjtcbiAgICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdObyB1c2VyIGxvZ2dlZCBpbicpO1xuXG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcgdG9waWM6Jywge1xuICAgICAgICB0b3BpY0lkLFxuICAgICAgICBuYW1lLFxuICAgICAgICB1cmw6IGAke0FQSV9VUkx9L2FwaS91c2Vycy8ke3VzZXIudWlkfS90b3BpY3MvJHt0b3BpY0lkfWBcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgICBgJHtBUElfVVJMfS9hcGkvdXNlcnMvJHt1c2VyLnVpZH0vdG9waWNzLyR7dG9waWNJZH1gLFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBuYW1lIH0pXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gICAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgJ0ZhaWxlZCB0byB1cGRhdGUgdG9waWMgbmFtZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCByZXNwb25zZTonLCB0ZXh0KTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgdXBkYXRlZFVzZXIgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBzZXRVc2VyRGF0YSh1cGRhdGVkVXNlcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgdG9waWMgbmFtZTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGFkZFRvcGljID0gYXN5bmMgKG5hbWU6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VyID0gYXV0aC5jdXJyZW50VXNlcjtcbiAgICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdObyB1c2VyIGxvZ2dlZCBpbicpO1xuXG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnU2VuZGluZyByZXF1ZXN0IHRvOicsIGAke0FQSV9VUkx9L2FwaS91c2Vycy8ke3VzZXIudWlkfS90b3BpY3NgKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYCR7QVBJX1VSTH0vYXBpL3VzZXJzLyR7dXNlci51aWR9L3RvcGljc2AsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBuYW1lIH0pXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gICAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgJ0ZhaWxlZCB0byBhZGQgdG9waWMnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgcmVzcG9uc2U6JywgdGV4dCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwZGF0ZWRVc2VyID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgc2V0VXNlckRhdGEodXBkYXRlZFVzZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyB0b3BpYzonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGdldENvbnRyaWJ1dGlvbkRhdGEgPSAoKTogQ29udHJpYnV0aW9uRGF0YVtdID0+IHtcbiAgICBpZiAoIXVzZXJEYXRhPy5jb250cmlidXRpb25zKSByZXR1cm4gW107XG4gICAgXG4gICAgLy8gU29ydCBjb250cmlidXRpb25zIGJ5IGRhdGVcbiAgICBjb25zdCBzb3J0ZWRDb250cmlidXRpb25zID0gWy4uLnVzZXJEYXRhLmNvbnRyaWJ1dGlvbnNdLnNvcnQoXG4gICAgICAoYSwgYikgPT4gbmV3IERhdGUoYS5kYXRlKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShiLmRhdGUpLmdldFRpbWUoKVxuICAgICk7XG4gICAgXG4gICAgcmV0dXJuIHNvcnRlZENvbnRyaWJ1dGlvbnMubWFwKChjb250cmlidXRpb246IE1vbmdvQ29udHJpYnV0aW9uKTogQ29udHJpYnV0aW9uRGF0YSA9PiAoe1xuICAgICAgZGF0ZTogY29udHJpYnV0aW9uLmRhdGUsXG4gICAgICBjb3VudDogY29udHJpYnV0aW9uLmNvdW50LFxuICAgICAgc3R1ZHlDb3VudDogY29udHJpYnV0aW9uLnN0dWR5Q291bnQgfHwgMCAgLy8g56K65L+d5pyJIHN0dWR5Q291bnRcbiAgICB9KSk7XG4gIH07XG5cbiAgY29uc3QgY29tcGxldGVNYXRlcmlhbCA9IGFzeW5jIChtYXRlcmlhbElkOiBzdHJpbmcsIHRvcGljSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VyID0gYXV0aC5jdXJyZW50VXNlcjtcbiAgICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKCdObyB1c2VyIGxvZ2dlZCBpbicpO1xuICBcbiAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7QVBJX1VSTH0vYXBpL3VzZXJzLyR7dXNlci51aWR9L3RvcGljcy8ke3RvcGljSWR9L21hdGVyaWFscy8ke21hdGVyaWFsSWR9L2NvbXBsZXRlYDtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1NlbmRpbmcgY29tcGxldGUgcmVxdWVzdCB0bzonLCBlbmRwb2ludCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdXNlci5nZXRJZFRva2VuKCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGVuZHBvaW50LCB7XG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvbXBsZXRlIG1hdGVyaWFsIGVycm9yIHJlc3BvbnNlOicsIGVycm9yRGF0YSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBlcnJvckRhdGEuZXJyb3IgfHwgJ0ZhaWxlZCB0byB1cGRhdGUgbWF0ZXJpYWwgY29tcGxldGlvbiBzdGF0dXMnKTtcbiAgICAgIH1cbiAgXG4gICAgICBjb25zdCB1cGRhdGVkVXNlciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHNldFVzZXJEYXRhKHVwZGF0ZWRVc2VyKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29tcGxldGluZyBtYXRlcmlhbDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdW5jb21wbGV0ZU1hdGVyaWFsID0gYXN5bmMgKG1hdGVyaWFsSWQ6IHN0cmluZywgdG9waWNJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhdXRoLmN1cnJlbnRVc2VyO1xuICAgICAgaWYgKCF1c2VyKSB0aHJvdyBuZXcgRXJyb3IoJ05vIHVzZXIgbG9nZ2VkIGluJyk7XG5cbiAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7QVBJX1VSTH0vYXBpL3VzZXJzLyR7dXNlci51aWR9L3RvcGljcy8ke3RvcGljSWR9L21hdGVyaWFscy8ke21hdGVyaWFsSWR9L3VuY29tcGxldGVgO1xuICAgICAgXG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChlbmRwb2ludCwge1xuICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gdXBkYXRlIG1hdGVyaWFsIGNvbXBsZXRpb24gc3RhdHVzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwZGF0ZWRVc2VyID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgc2V0VXNlckRhdGEodXBkYXRlZFVzZXIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1bmNvbXBsZXRpbmcgbWF0ZXJpYWw6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGRlbGV0ZU1hdGVyaWFsID0gYXN5bmMgKG1hdGVyaWFsSWQ6IHN0cmluZywgdG9waWNJZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhdXRoLmN1cnJlbnRVc2VyO1xuICAgICAgaWYgKCF1c2VyKSB0aHJvdyBuZXcgRXJyb3IoJ05vIHVzZXIgbG9nZ2VkIGluJyk7XG5cbiAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7QVBJX1VSTH0vYXBpL3VzZXJzLyR7dXNlci51aWR9L3RvcGljcy8ke3RvcGljSWR9L21hdGVyaWFscy8ke21hdGVyaWFsSWR9YDtcbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdXNlci5nZXRJZFRva2VuKCk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdEZWxldGUgbWF0ZXJpYWwgcmVxdWVzdDonLCB7XG4gICAgICAgIGVuZHBvaW50LFxuICAgICAgICBtYXRlcmlhbElkLFxuICAgICAgICB0b3BpY0lkLFxuICAgICAgICB1c2VyVWlkOiB1c2VyLnVpZFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZW5kcG9pbnQsIHtcbiAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0RlbGV0ZSBtYXRlcmlhbCBmYWlsZWQ6JywgZXJyb3JEYXRhKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCBmZXRjaFVzZXJEYXRhKHVzZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0RlbGV0ZSBtYXRlcmlhbCBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7IFxuICAgIHVzZXJEYXRhLCBcbiAgICBsb2FkaW5nLCBcbiAgICBmZXRjaFVzZXJEYXRhLCBcbiAgICBhZGRNYXRlcmlhbCxcbiAgICB1cGRhdGVQcm9maWxlLFxuICAgIGFkZFRvcGljLFxuICAgIHVwZGF0ZVRvcGljTmFtZSxcbiAgICBnZXRDb250cmlidXRpb25EYXRhLFxuICAgIGNvbXBsZXRlTWF0ZXJpYWwsXG4gICAgdW5jb21wbGV0ZU1hdGVyaWFsLFxuICAgIGRlbGV0ZU1hdGVyaWFsXG4gIH07XG59OyJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUZpcmViYXNlIiwiQVBJX1VSTCIsInVzZVVzZXJEYXRhIiwiYXV0aCIsInVzZXJEYXRhIiwic2V0VXNlckRhdGEiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImZldGNoVXNlckRhdGEiLCJjdXJyZW50VXNlciIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiY29uc29sZSIsImxvZyIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImNhY2hlS2V5IiwidWlkIiwiY2FjaGVkRGF0YSIsInNlc3Npb25TdG9yYWdlIiwiZ2V0SXRlbSIsImRhdGEiLCJ0aW1lc3RhbXAiLCJKU09OIiwicGFyc2UiLCJjYWNoZUFnZSIsIk1hdGgiLCJyb3VuZCIsInRva2VuU3RhcnRUaW1lIiwidG9rZW4iLCJnZXRJZFRva2VuIiwiZmV0Y2hTdGFydFRpbWUiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsImpzb24iLCJmZXRjaEVuZFRpbWUiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiZXJyb3IiLCJlbmRUaW1lIiwiaXNNb3VudGVkIiwidW5zdWJzY3JpYmUiLCJvbkF1dGhTdGF0ZUNoYW5nZWQiLCJ1c2VyIiwiYWRkTWF0ZXJpYWwiLCJtYXRlcmlhbERhdGEiLCJ0b3BpY0lkIiwiRXJyb3IiLCJlbmRwb2ludCIsInBheWxvYWQiLCJ1cmwiLCJtZXRob2QiLCJib2R5Iiwib2siLCJlcnJvclRleHQiLCJ0ZXh0Iiwic3RhdHVzIiwidXBkYXRlZFVzZXIiLCJ1cGRhdGVQcm9maWxlIiwiZXJyb3JEYXRhIiwidXBkYXRlVG9waWNOYW1lIiwibmFtZSIsImNvbnRlbnRUeXBlIiwiZ2V0IiwiaW5jbHVkZXMiLCJhZGRUb3BpYyIsImdldENvbnRyaWJ1dGlvbkRhdGEiLCJjb250cmlidXRpb25zIiwic29ydGVkQ29udHJpYnV0aW9ucyIsInNvcnQiLCJhIiwiYiIsImRhdGUiLCJnZXRUaW1lIiwibWFwIiwiY29udHJpYnV0aW9uIiwiY291bnQiLCJzdHVkeUNvdW50IiwiY29tcGxldGVNYXRlcmlhbCIsIm1hdGVyaWFsSWQiLCJtZXNzYWdlIiwidW5jb21wbGV0ZU1hdGVyaWFsIiwiZGVsZXRlTWF0ZXJpYWwiLCJ1c2VyVWlkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useUserData.ts\n"));

/***/ })

});